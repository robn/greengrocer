#!/usr/bin/env perl

package greengrocer;

use 5.014;
use warnings;
use strict;

use Lucy;
use Path::Tiny;
use AnyEvent::Log;
use AnyEvent::Handle;
use AnyEvent::Handle::UDP;
use Date::Format qw(time2str);
use Date::Parse qw(str2time);
use Getopt::Std qw(getopts);
use Time::HiRes qw(gettimeofday tv_interval);
use JSON::XS qw(decode_json);
use IO::Socket::INET;
use Socket qw(SOL_SOCKET SO_RCVBUF);
use POSIX qw(_exit);

getopts('d:h', \my %OPTS);

my $INDEX_DIR = $OPTS{d};

my $ACTION = shift @ARGV;
my $handler = {
    agent    => \&agent,
    search   => \&search,
    optimize => \&optimize,
    web      => \&web,
}->{$ACTION // ''};

say STDERR "E: unknown action: $ACTION" if $ACTION && !$handler;
usage() if !$INDEX_DIR || $OPTS{h} || !$ACTION || !$handler;

path($INDEX_DIR)->mkpath;

$handler->(@ARGV);

sub agent {
    local @ARGV = @_;
    getopts('l:p:i:h:', \my %opts);

    my $ip = $opts{l} // '0.0.0.0';
    my $port = $opts{p} // 5514;

    my $log = logger();

    my $cv = AnyEvent::condvar;

    my $interval = (0+($opts{i} // 0)) || 10;

    my $roll_hours = $opts{h} // 24;

    $log->("commit interval is $interval, rolling every $roll_hours hours");

    $roll_hours %= 24;

    my @queue;

    my $child_guard;
    my $queue_guard; $queue_guard = AnyEvent->timer(
        after    => $interval,
        interval => $interval,
        cb => sub {
            return unless @queue;

            if ($child_guard) {
                $log->("commit in progress, deferring");
                return;
            }

            my @commit_queue = @queue;
            undef @queue;

            my $pid = fork;
            if ($pid < 0) {
                $log->("fork failed: $!");
                $log->("returning ", scalar(@commit_queue), " lines to the queue");
                push @queue, @commit_queue;
                return;
            }

            if ($pid) {
                $child_guard = AnyEvent->child(
                    pid => $pid,
                    cb => sub {
                        undef $child_guard;
                    },
                );
                return;
            }

            my %indexers;

            my ($t_start, $t_add, $t_commit);

            $t_start = [gettimeofday];

            for my $data (@commit_queue) {
                @$data{qw(program pid)} = delete($data->{syslogtag}) =~ m/^([^\[]+)(?:\[(\d+)\])?:$/;
                $data->{pid} //= '';

                my ($y, $m, $d, $h) = $data->{timestamp} =~ m/^(\d+)-(\d+)-(\d+)T(\d+)/;
                unless (defined $y && defined $m && defined $d && defined $h) {
                    $log->("E: malformed timestamp: $data->{timestamp}");
                }

                my $key = "$y$m$d";
                if ($roll_hours) {
                    my $roll = int($h / $roll_hours);
                    $key .= $roll >= 10 ? "_$roll" : "_0$roll";
                }

                ($indexers{$key} ||= Lucy::Index::Indexer->new(
                    index    => path($INDEX_DIR, $key),
                    schema => schema(),
                    create => 1,
                ))->add_doc($data);
            }

            $t_add = [gettimeofday];

            for my $indexer (values %indexers) {
                $indexer->commit;
            };

            $t_commit = [gettimeofday];

            my $e_add     = tv_interval($t_start, $t_add);
            my $e_commit  = tv_interval($t_add, $t_commit);

            my $n_items = scalar @commit_queue;

            my $r_add    = $e_add / $n_items;
            my $r_commit = $e_commit / $n_items;

            $log->("indexed %d lines [add %.3f (%.6f) commit %.3f (%.6f)]", $n_items, $e_add, $r_add, $e_commit, $r_commit);

            POSIX::_exit(0);
        },
    );

    my $server; $server = AnyEvent::Handle::UDP->new(
        bind => [$ip, $port],
        on_recv => sub {
            my ($data, $handle, $client_addr) = @_;
            eval { push @queue, decode_json($data) };
            if (my $err = $@) {
                $log->("data error: $@: $data");
            }
        },
        on_error => sub {
            my ($handle, $is_fatal, $msg) = @_;
            my $peer = $handle->getpeername;
            $log->("$peer error: $msg");
            $handle->destroy;
        },
    );

    $server->fh->setsockopt(SOL_SOCKET, SO_RCVBUF, 64*1024*1024) or
      $log->("setsockopt: $!");

    my $rcvbuf = $server->fh->getsockopt(SOL_SOCKET, SO_RCVBUF);
    $log->("listening on $ip:$port, receive buffer is $rcvbuf bytes");

    $cv->recv;
}

sub search {
    local @ARGV = @_;
    getopts('s:e:j', \my %opts);

    run_search(
        start     => $opts{s},
        end       => $opts{e},
        query     => join(' ', @ARGV),
        collector => sub {
            my ($searcher, $query) = @_;
            greengrocer::CLICollector->new(searcher => $searcher, json => !!$opts{j}),
        },
        error => sub {
            my ($msg) = @_;
            say STDERR "E: $msg";
            usage();
        },
    );
}

sub optimize {
    local @ARGV = @_;

    for my $index (@ARGV) {
        my $indexer = eval {
            Lucy::Index::Indexer->new(
                index  => path($INDEX_DIR, $index),
                schema => schema(),
            );
        };
        if ($@) {
            warn "E: couldn't open index $index, skipping\n";
            next;
        }

        print STDERR "indexing $index... ";
        STDERR->flush;

        $indexer->optimize;
        $indexer->commit;

        say STDERR "done";
    }
}

sub web {
    my @modules = qw(Twiggy Atto);
    my @missing = grep { ! eval "require $_" } qw(Twiggy::Server Atto);
    if (@missing) {
        say STDERR "E: the web server requires these additional modules: @modules";
        say STDERR "E: try running: cpanm @modules";
        exit 1;
    }

    local @ARGV = @_;
    getopts('l:p:', \my %opts);

    my $ip = $opts{l} // '0.0.0.0';
    my $port = $opts{p} // 5515;

    my $log = logger();

    my $cv = AnyEvent::condvar;

    my $server = Twiggy::Server->new(host => $ip, port => $port);
    $server->register_service(greengrocer::SearchServer->psgi(logger => $log));

    $log->("$ip:$port listening");

    $cv->recv;
}

sub logger {
    AnyEvent::Log::ctx->log_to_warn;
    AnyEvent::Log::ctx->fmt_cb(sub {
            sprintf "[greengrocer] %s %s\n", time2str("%Y-%m-%dT%H:%M:%S", time), $_[3];
    });
    AnyEvent::Log::logger("notice");
}

sub schema {
    # {"pid":"4090299","timestamp":"2015-12-21T18:47:30.697022-05:00","program":"sloti30t15/calalarmd","host":"imap30","message":" processing alarms"}

    state $schema = do {
        my $s = Lucy::Plan::Schema->new;

        $s->spec_field(
            name => 'timestamp',
            type => Lucy::Plan::StringType->new(
                sortable => 1,
            ),
        );
        $s->spec_field(
            name => 'host',
            type => Lucy::Plan::StringType->new,
        );
        $s->spec_field(
            name => 'program',
            type => Lucy::Plan::FullTextType->new(
                analyzer => Lucy::Analysis::StandardTokenizer->new,
            ),
        );
        $s->spec_field(
            name => 'pid',
            type => Lucy::Plan::StringType->new,
        );
        $s->spec_field(
            name => 'message',
            type => Lucy::Plan::FullTextType->new(
                analyzer => Lucy::Analysis::StandardTokenizer->new,
            ),
        );

        $s;
    };

    return $schema;
}

sub run_search {
    my (%args) = @_;

    my $now = time;
    my $start_date = time2str("%Y%m%d", str2time($args{start}) // $now);
    my $end_date   = time2str("%Y%m%d", str2time($args{end}) // ($now+86400));
    if ($start_date ge $end_date) {
        $args{error}->("invalid date range $start_date - $end_date");
        return;
    }

    my $query_parser = Lucy::Search::QueryParser->new(schema => schema());
    $query_parser->set_heed_colons(1);
    my $query = $query_parser->parse($args{query} // '');

    my $top_dir = path($INDEX_DIR);
    my @indexes = grep { my ($basename) = $_->basename =~ m/^(\d+)/; $basename >= $start_date && $basename < $end_date } $top_dir->children;
    say for @indexes;
    my @searchers = map { Lucy::Search::IndexSearcher->new(index => $_) } @indexes;
    my $searcher = Lucy::Search::PolySearcher->new(
        schema => schema(),
        searchers => \@searchers,
    );

    my $collector = $args{collector}->($searcher, $query);

    do {
        no warnings 'uninitialized'; # working around slight bug inside Lucy
        $searcher->collect(
            query => $query,
            collector => $collector,
        );
    };
}

sub usage {
    my $action = $ACTION // '';

    if ($action eq 'agent') {
        print STDERR <<USAGE;
Usage: greengrocer -d <index-dir> agent [opts...]

Starts the log collection agent. The agent itself will log info about
its activities to standard error.

Options:
    -l <ip>       - IP address to listen on [default: all]
    -p <port>     - port to listen on [default: 5514]
    -i <interval> - commit logs to index every N seconds [default: 10]
    -h <hours>    - create new index within each day every N hours [default: 24]
USAGE
    }
    elsif ($action eq 'search') {
        print STDERR <<USAGE;
Usage: greengrocer -d <index-dir> search [opts...] <query...>

Searches for log lines matching the given query.

Options:
    -s <date> - start date to search (inclusive) [default: today]
    -e <date> - end date to search (exclusive) [default: tomorrow]
    -j        - JSON output
USAGE
    }
    elsif ($action eq 'web') {
        print STDERR <<USAGE;
Usage: greengrocer -d <index-dir> web [opts...]

Starts the web search API server. The server will log requests to standard
error.

Options:
    -l <ip>       - IP address to listen on [default: all]
    -p <port>     - port to listen on [default: 5515]

To run a search, make a web request to the /search endpoint with the following
query parameters:

    start - start date to search (inclusive) [default: today]
    end   - end date to search (exclusive) [default: tomorrow]
    query - query string

Example:

    \$ curl http://127.0.0.1:5515/search?query=info

USAGE
    }
    elsif ($action eq 'optimize') {
        print STDERR <<USAGE;
Usage: greengrocer -d <index-dir> optimize <indexes...>

Optimizes a indexes for fast searching. Indexes can become fragmented after a
lot of writes, which can make searching slower. Optimizing reprocesses the log
lines into a new unfragmented index which takes less effort to search. It
usually won't make the index significantly smaller.

Optimizing an index can take a long time (minutes) and locks the index for
writing, so new log entries cannot be added. For this reason don't try to
optimize an active index (that is, today's) or you'll likely end up losing
incoming log lines.
USAGE
    }
    else {
        print STDERR <<USAGE;
Usage: greengrocer -d <index-dir> <action> [opts...]

Global options:
    -d <index-dir> - location to store indexes

Actions:
    agent    - run the log collection agent
    search   - show log lines matching a query
    web      - run the web search API server
    optimize - optimize indexes for searching

For more help on action: greengrocer <action> -h
USAGE
    }

    exit 1;
}


package greengrocer::CLICollector;

use parent qw(Lucy::Search::Collector);
use JSON::XS;

our %self;

sub new {
    my ($class, %args) = @_;

    my $ref = $class->SUPER::new;

    $self{$ref} = {
        searcher => $args{searcher},
        base     => 0,
        json     => $args{json},
    };

    return $ref;
}

sub DESTROY {
    my ($ref) = @_;
    my $self = delete $self{$ref};
    if ($self->{json}) {
        if ($self->{started}) {
            say "\n]";
        }
        else {
            say "[]";
        }
    }
}

sub _output_text {
    my ($self, $doc) = @_;
    my ($timestamp, $host, $program, $pid, $message) = map { $doc->{$_} } qw(timestamp host program pid message);
    $pid = "[$pid]" if $pid;
    printf "%s %s %s%s:%s\n", $timestamp, $host, $program, $pid, $message;
}

sub _output_json {
    my ($self, $doc) = @_;

    unless ($self->{started}) {
        say '[';
        $self->{started} = 1;
    }
    else {
        say ',';
    }

    print '  ', encode_json({ map { $_ => $doc->{$_} } qw(timestamp host program pid message) });
}

sub collect {
    my ($ref, $doc_id) = @_;
    my $self = $self{$ref};
    my $doc = $self->{searcher}->fetch_doc($self->{base} + $doc_id);
    if ($self->{json}) {
        _output_json($self, $doc);
    }
    else {
        _output_text($self, $doc);
    }
}

sub set_base {
    my ($ref, $base) = @_;
    my $self = $self{$ref};
    $self->{base} = $base;
}

sub need_score { 0 }


package greengrocer::ServerCollector;

use parent qw(Lucy::Search::Collector);

our %self;

sub new {
    my ($class, %args) = @_;

    my $ref = $class->SUPER::new;

    $self{$ref} = {
        searcher => $args{searcher},
        base     => 0,
        results  => [],
    };

    return $ref;
}

sub results {
    my ($ref) = @_;
    my $self = $self{$ref};
    $self->{results};
}

sub DESTROY {
    my ($ref) = @_;
    my $self = delete $self{$ref};
}

sub collect {
    my ($ref, $doc_id) = @_;
    my $self = $self{$ref};
    my $doc = $self->{searcher}->fetch_doc($self->{base} + $doc_id);
    push @{$self->{results}}, { map { $_ => $doc->{$_} } qw(timestamp host program pid message) };
}

sub set_base {
    my ($ref, $base) = @_;
    my $self = $self{$ref};
    $self->{base} = $base;
}

sub need_score { 0 }


package greengrocer::SearchServer;

our $log;

sub psgi {
    my ($class, %args) = @_;
    $log = $args{logger};

    Atto->import(qw(search));
    Atto->psgi;
}

sub search {
    my (%args) = @_;

    my $info = join(' ', map { "$_=$args{$_}" } sort keys %args);

    my $collector;

    greengrocer::run_search(
        start     => $args{start},
        end       => $args{end},
        query     => $args{query},
        collector => sub {
            my ($searcher, $query) = @_;
            $collector = greengrocer::ServerCollector->new(searcher => $searcher);
            return $collector;
        },
        error => sub {
            my ($msg) = @_;
            $log->("search: $info [FAILED: $msg]");
            die "E: $msg\n";
        },
    );

    my $results = $collector->results;

    $log->(sprintf "search: %s [results: %d]", join(' ', map { "$_=$args{$_}" } sort keys %args), scalar @$results);

    return $results
}
