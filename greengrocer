#!/usr/bin/env perl

package greengrocer;

use 5.014;
use warnings;
use strict;

use Lucy;
use Path::Tiny;
use AnyEvent::Log;
use AnyEvent::Socket;
use AnyEvent::Handle;
use Date::Format qw(time2str);
use Date::Parse qw(str2time);
use Getopt::Std qw(getopts);

getopts('d:h', \my %OPTS);

my $INDEX_DIR = $OPTS{d};

my $ACTION = shift @ARGV;
my $handler = {
    daemon => \&daemon,
    search => \&search,
}->{$ACTION // ''};

say STDERR "E: unknown action: $ACTION" if $ACTION && !$handler;
usage() if !$INDEX_DIR || $OPTS{h} || !$ACTION || !$handler;

path($INDEX_DIR)->mkpath;

$handler->(@ARGV);

sub daemon {
    local @ARGV = @_;
    getopts('l:p:', \my %opts);

    my $ip = $opts{l};
    my $port = $opts{p} // 5514;

    AnyEvent::Log::ctx->log_to_warn;
    AnyEvent::Log::ctx->fmt_cb(sub {
            sprintf "[greengrocer] %s %s\n", time2str("%Y-%m-%dT%H:%M:%S", time), $_[3];
    });
    my $log = AnyEvent::Log::logger("notice");

    my $cv = AnyEvent::condvar;

    my @queue;
    my $queue_guard; $queue_guard = AnyEvent->timer(
        after        => 1,
        interval => 1,
        cb => sub {
            return unless @queue;

            my %indexers;

            for my $data (@queue) {
                @$data{qw(program pid)} = delete($data->{syslogtag}) =~ m/^([^\[]+)(?:\[(\d+)\])?:$/;
                $data->{pid} //= '';

                my ($y, $m, $d) = split '-', substr($data->{timestamp}, 0, 10);
                unless ($y && $m && $d) {
                    $log->("E: malformed timestamp: $data->{timestamp}");
                }
                my $key = "$y$m$d";

                ($indexers{$key} ||= Lucy::Index::Indexer->new(
                    index    => path($INDEX_DIR, $key),
                    schema => schema(),
                    create => 1,
                ))->add_doc($data);
            }

            for my $indexer (values %indexers) {
                $indexer->commit;
            };

            $log->("indexed ".scalar(@queue)." lines");
            undef @queue;
        },
    );

    tcp_server($ip, $port,
        sub {
            my ($fh, $host, $port) = @_;

            $log->("$host:$port connect");

            my $handle; $handle = AnyEvent::Handle->new(
                fh => $fh,
                on_error => sub {
                    my $msg = pop @_;
                    $handle->destroy;
                    $log->("$host:$port error: $msg");
                },
                on_eof => sub {
                    $handle->destroy;
                    $log->("$host:$port disconnect");
                },
            );

            my $reader; $reader = sub {
                push @queue, $_[-1];
                $handle->push_read(json => $reader);
            };
            $handle->push_read(json => $reader);
        },
        sub {
            my ($fh, $host, $port) = @_;
            $log->("$host:$port listening");
        },
    );

    $cv->recv;
}

sub search {
    local @ARGV = @_;
    getopts('s:e:j', \my %opts);

    my $now = time;
    my $start_date = time2str("%Y%m%d", str2time($opts{s}) // $now);
    my $end_date     = time2str("%Y%m%d", str2time($opts{e}) // ($now+86400));
    if ($start_date ge $end_date) {
        say STDERR "E: invalid date range $start_date - $end_date";
        usage();
    }

    my $query_parser = Lucy::Search::QueryParser->new(schema => schema());
    $query_parser->set_heed_colons(1);
    my $query = $query_parser->parse(join ' ', @ARGV);

    my $top_dir = path($INDEX_DIR);
    my @indexes = grep { my $basename = $_->basename; $basename >= $start_date && $basename < $end_date } $top_dir->children;
    my @searchers = map { Lucy::Search::IndexSearcher->new(index => $_) } @indexes;
    my $searcher = Lucy::Search::PolySearcher->new(
        schema => schema(),
        searchers => \@searchers,
    );

    my $collector = greengrocer::HitCollector->new(searcher => $searcher, json => !!$opts{j});

    do {
        no warnings 'uninitialized'; # working around slight bug inside Lucy
        $searcher->collect(
            query => $query,
            collector => $collector,
        );
    };
}

sub schema {
    # {"pid":"4090299","timestamp":"2015-12-21T18:47:30.697022-05:00","program":"sloti30t15/calalarmd","host":"imap30","message":" processing alarms"}

    state $schema = do {
        my $s = Lucy::Plan::Schema->new;

        $s->spec_field(
            name => 'timestamp',
            type => Lucy::Plan::StringType->new(
                sortable => 1,
            ),
        );
        $s->spec_field(
            name => 'host',
            type => Lucy::Plan::StringType->new,
        );
        $s->spec_field(
            name => 'program',
            type => Lucy::Plan::FullTextType->new(
                analyzer => Lucy::Analysis::StandardTokenizer->new,
            ),
        );
        $s->spec_field(
            name => 'pid',
            type => Lucy::Plan::StringType->new,
        );
        $s->spec_field(
            name => 'message',
            type => Lucy::Plan::FullTextType->new(
                analyzer => Lucy::Analysis::StandardTokenizer->new,
            ),
        );

        $s;
    };

    return $schema;
}

sub usage {
    my $action = $ACTION // '';

    if ($action eq 'daemon') {
        print STDERR <<USAGE;
Usage: greengrocer -d <index-dir> daemon [opts...]

Starts the log collection daemon. The daemon itself will log info about
its activities to standard error.

Options:
    -l <ip>     - IP address to listen on [default: all]
    -p <port> - port to listen on [default: 5514]
USAGE
    }
    elsif ($action eq 'search') {
        print STDERR <<USAGE;
Usage: greengrocer -d <index-dir> search [opts...] <query...>

Searches for log lines matching the given query.

Options:
    -s <date> - start date to search (inclusive) [default: today]
    -e <date> - end date to search (exclusive) [default: tomorrow]
    -j        - JSON output
USAGE
    }
    else {
        print STDERR <<USAGE;
Usage: greengrocer -d <index-dir> <action> [opts...]

Global options:
    -d <index-dir> - location to store indexes

Actions:
    daemon - run the log collection daemon
    search - show log lines matching a query

For more help on action: greengrocer <action> -h
USAGE
    }

    exit 1;
}


package greengrocer::HitCollector;

use parent qw(Lucy::Search::Collector);
use JSON::XS;

our %self;

sub new {
    my ($class, %args) = @_;

    my $ref = $class->SUPER::new;

    $self{$ref} = {
        searcher => $args{searcher},
        base     => 0,
        json     => $args{json},
    };

    return $ref;
}

sub DESTROY {
    my ($ref) = @_;
    my $self = delete $self{$ref};
    say "\n]" if $self->{json};
}

sub _output_text {
    my ($self, $doc) = @_;
    my ($timestamp, $host, $program, $pid, $message) = map { $doc->{$_} } qw(timestamp host program pid message);
    $pid = "[$pid]" if $pid;
    printf "%s %s %s%s:%s\n", $timestamp, $host, $program, $pid, $message;
}

sub _output_json {
    my ($self, $doc) = @_;

    unless ($self->{started}) {
        say '[';
        $self->{started} = 1;
    }
    else {
        say ',';
    }

    print '  ', encode_json({ map { $_ => $doc->{$_} } qw(timestamp host program pid message) });
}

sub collect {
    my ($ref, $doc_id) = @_;
    my $self = $self{$ref};
    my $doc = $self->{searcher}->fetch_doc($self->{base} + $doc_id);
    if ($self->{json}) {
        _output_json($self, $doc);
    }
    else {
        _output_text($self, $doc);
    }
}

sub set_base {
    my ($ref, $base) = @_;
    my $self = $self{$ref};
    $self->{base} = $base;
}

sub need_score { 0 }
